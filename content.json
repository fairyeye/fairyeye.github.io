{"meta":{"title":"人生当苦, 良人当归","subtitle":"","description":"我不过像你像他像那野草野花。","author":"有李说不清","url":"https://fairyeye.github.io","root":"/"},"pages":[{"title":"","date":"2023-06-05T01:28:10.943Z","updated":"2023-06-05T01:28:10.943Z","comments":true,"path":"404/404.html","permalink":"https://fairyeye.github.io/404/404.html","excerpt":"","text":""},{"title":"","date":"2023-06-05T01:28:10.943Z","updated":"2023-06-05T01:28:10.943Z","comments":true,"path":"404.html","permalink":"https://fairyeye.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2023-06-05T01:28:10.959Z","updated":"2023-06-05T01:28:10.959Z","comments":true,"path":"about/index.html","permalink":"https://fairyeye.github.io/about/index.html","excerpt":"","text":"This is About."},{"title":"all","date":"2020-04-27T06:26:32.000Z","updated":"2023-06-05T05:49:50.607Z","comments":true,"path":"tags/index.html","permalink":"https://fairyeye.github.io/tags/index.html","excerpt":"","text":""},{"title":"category","date":"2020-04-27T06:30:47.000Z","updated":"2023-06-05T01:28:10.959Z","comments":true,"path":"categories/index.html","permalink":"https://fairyeye.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Git","slug":"GIT","date":"2023-06-17T14:33:35.000Z","updated":"2023-06-20T02:33:58.436Z","comments":true,"path":"2023/06/17/GIT/","link":"","permalink":"https://fairyeye.github.io/2023/06/17/GIT/","excerpt":"","text":"# Gitee Go # 流水线 12# 官方文档https://blog.gitee.com/2022/11/23/pipeline/ # 前端 CI 手动创建流水线，选择部署分之，需要手动增加部署阶段 # 添加部署阶段 点击发布后面的＋ 添加新阶段 点击部署 点击主机部署 选择执行主机组（如果没有就先去添加主机，选择 填写部署脚本，前端项目把上游构建的包，解压到服务器指定路径即可 12345678910# 功能：部署脚本会在部署主机组的每台机器上执行# 使用场景：先将制品包解压缩到指定目录中，再执行启动脚本deploy.sh，脚本示例地址：https://gitee.com/gitee-go/spring-boot-maven-deploy-case/blob/master/deploy.sh# mkdir -p /home/admin/app# tar zxvf ~/gitee_go/deploy/output.tar.gz -C /home/admin/app# sh /home/admin/app/deploy.sh restart# 如果你是php之类的无需制品包的制品方式，可以使用 git clone 或者 git pull 将源代码更新到服务器，再执行其他命令# git clone ***@***.gittar zxvf ~/gitee_go/deploy/output.tar.gz -C /home/ubuntu # 添加主机 点击新建主机组 选择新建类型（以腾讯云为例），填写基本信息（以 Linux 为例），点击确认 添加主机 点击添加 Linux 主机，选择通过命令行逐台添加， 复制命令到目标腾讯云主机命令行 刷新页面即可见关联服务器信息 # 后端 CI # 部署脚本 12345678910111213cd ~/gitee_go/deploy/lstar -zxf API.tar.gzcd targetpid=`ps -ef|grep smart-admin-api-1.0.0|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`if [ $pid ]thensudo kill -15 $pid fisudo nohup /usr/lib/jvm/jdk1.8.0_341/bin/java -jar smart-admin-api-1.0.0.jar &gt;/home/ubuntu/log.log &amp; 123456789101112131415161718cd ~/gitee_go/deploy/lstar -zxf API.tar.gzcd targetpid=`ps -ef|grep smart-admin-api-1.0.0|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`if [ $pid ]thensudo kill -15 $pid fisudo nohup /usr/lib/jvm/jdk1.8.0_341/bin/java -jar smart-admin-api-1.0.0.jar&gt; /home/ubuntu/log.log 2&gt;&amp;1 &amp;","categories":[{"name":"use","slug":"use","permalink":"https://fairyeye.github.io/categories/use/"}],"tags":[{"name":"git","slug":"git","permalink":"https://fairyeye.github.io/tags/git/"}]},{"title":"GitHub Page","slug":"GitHub Page","date":"2023-06-05T06:10:07.408Z","updated":"2023-06-05T06:11:05.499Z","comments":true,"path":"2023/06/05/GitHub Page/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/GitHub%20Page/","excerpt":"","text":"123## 拉取子模块git submodule init // 初始化子模块git submodule update // 更新子模块与主仓库中的子模块代码同步","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://fairyeye.github.io/tags/hexo/"}]},{"title":"单例模式","slug":"单例模式","date":"2023-06-05T05:49:50.605Z","updated":"2023-06-05T05:49:50.605Z","comments":true,"path":"2023/06/05/单例模式/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"# 1. 最简单的单例模式： 123456789101112131415161718192021222324252627282930package com.example.demo.JUC.thread;/** * @author huapeng.zhang * @version 1.0 * @date 2020/9/17 18:28 */public class SingletomDemo &#123; private static SingletomDemo singletomDemo = null; private SingletomDemo() &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 我是构造方法SingletomDemo()！&quot;); &#125; public static SingletomDemo getInstance() &#123; if (singletomDemo == null) &#123; singletomDemo = new SingletomDemo(); &#125; return singletomDemo; &#125; public static void main(String[] args) &#123; // 单线程 System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance()); System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance()); System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance()); &#125;&#125; 在单线程的情况下，打印结果如下： 可以看到，虽然我们一共调用了六次 getInstance() ， 但是只打印了一次构造方法输出内容，也就是只调用了一个构造函数，所获得的对象地址自然是一样的。 # 2. 多线程下的单例模式 我们对 main() 方法做一下改造，改造后的代码如下： 12345678public static void main(String[] args) &#123; // 改为多线程后 可能多次调用构造函数 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletomDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125;&#125; 打印结果为： 多次执行下可以看到打印的次数是不同的。 可以对 getInstance() 方法添加 synchronized 加锁，保证只生成一个实例。 123456private static synchronized SingletomDemo getInstance() &#123; if (singletomDemo == null) &#123; singletomDemo = new SingletomDemo(); &#125; return singletomDemo;&#125; 再次执行程序发现只打印了一次构造方法输出函数，还有另外一种方法就是 DCL：double check locks双端检测模式 模式也可以达到同样的目的。 # 3.DCL + 单例模式 我们再次对 getInstance() 方法进行改造，代码如下： 1234567891011// DCL模式(double check locks双端检测模式)private static SingletomDemo getInstance() &#123; if (singletomDemo == null) &#123; synchronized (SingletomDemo.class) &#123; if (singletomDemo == null) &#123; singletomDemo = new SingletomDemo(); &#125; &#125; &#125; return singletomDemo;&#125; 当我们的单例模式写到这种程度的时候，基本可以应对 99% 的情况，但是由于 指令排序 的存在，还是有可能会出现问题。 123memory = allocate(); //1.分配对象内存空间instance(memory); //2.初始化对象instance = memory; //3.设置instance指向刚分配的内存地址，此时instance!=null 步骤 2、3 不存在数据依赖，所以由于指令重排的关系，可能会出现： 123memory = allocate(); //1.分配对象内存空间instance = memory; //3.设置instance指向刚分配的内存地址，此时instance!=nullinstance(memory); //2.初始化对象 # 4.Volatile + 单例模式 我们在声明 singletomDemo 时，加上 Volatile 关键字修饰，就可以达到完美的效果。 最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.example.demo.JUC.thread;/** * @author huapeng.zhang * @version 1.0 * @date 2020/9/17 18:28 */public class SingletomDemo &#123; private static volatile SingletomDemo singletomDemo = null; private SingletomDemo() &#123; System.out.println(Thread.currentThread().getName() + &quot;\\t 我是构造方法SingletomDemo()！&quot;); &#125; // DCL模式(double check locks双端检测模式) private static SingletomDemo getInstance() &#123; if (singletomDemo == null) &#123; synchronized (SingletomDemo.class) &#123; if (singletomDemo == null) &#123; singletomDemo = new SingletomDemo(); &#125; &#125; &#125; return singletomDemo; &#125; public static void main(String[] args) &#123; // 单线程// System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance());// System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance());// System.out.println(SingletomDemo.getInstance() == SingletomDemo.getInstance());// 改为多线程后 可能多次调用构造函数// 可以在 getInstance上加SYNC解决问题 for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; SingletomDemo.getInstance(); &#125;, String.valueOf(i)).start(); &#125; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fairyeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"demo","slug":"demo","permalink":"https://fairyeye.github.io/tags/demo/"}]},{"title":"MySQL查询","slug":"同步不同服务的MySQL数据表","date":"2023-06-05T05:49:50.605Z","updated":"2023-06-05T05:49:50.605Z","comments":true,"path":"2023/06/05/同步不同服务的MySQL数据表/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E5%90%8C%E6%AD%A5%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1%E7%9A%84MySQL%E6%95%B0%E6%8D%AE%E8%A1%A8/","excerpt":"","text":"# 1. 首先要保证本地的 MySQL 服务支持 FEDERATED 引擎。 12345输入：SHOW ENGINES;如下 FEDERATED 行的Support为YES则表示开启了FEDERATED。如果为 NO 则表示未开启。如果 FEDERATED 没有开启的话 要启用。 # 2. 启用 FEDERATED 123在MySQL的配置文件安装目录下的my.ini或my.cnf 加上 一行 `FEDERATED` # 3. 建表 建表一般应的是 InnoDB 引擎，这里需要修改一下 改为 ENGINE=FEDERATED 从原表导出表结构 SQL，然后修改 ENGINE = InnoDB -&gt; ENGINE=FEDERATED CONNECTION='mysql://用户名:密码@IP:PORT/库名/表名' 然后打开这张表，可以看到远程表里的数据已经同步到了这张表。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"utils","slug":"utils","permalink":"https://fairyeye.github.io/tags/utils/"}]},{"title":"WHEN YOU HAVE A NEW PC","slug":"WHEN YOU HAVE A NEW PC","date":"2023-06-05T05:49:50.604Z","updated":"2023-06-05T07:20:43.969Z","comments":true,"path":"2023/06/05/WHEN YOU HAVE A NEW PC/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/WHEN%20YOU%20HAVE%20A%20NEW%20PC/","excerpt":"","text":"# &lt;center&gt; WHEN YOU HAVE A NEW PC&lt;/center&gt; # Java 环境配置 # 1. 安装 ​ 提前新建两个文件夹，jdk，jre，默认路径也可以 ​ 安装 jdk-8u111-windows-x64.exe ​ 设置 jdk、jre 的路径 # 2. 配置环境变量 ​ 右键此电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 (S) ​ 只有系统变量才是全局的。 123456新建 CLASSPATH .;新建 JAVA_HOME jdk路径修改 path 添加 %JAVA_HOME%\\bin;测试 java -version javac -version # Maven 环境配置 解压 apache-maven-3.3.9.rar 到指定的目录。 修改配置文件（压缩包已修改过）。 # GIT 工具 # 1. 全局配置用户信息 12git config --global user.name &quot;fairy&quot;git config --global user.email &quot;fairy@gmail.com&quot; # 2. 生成 key 1ssh-keygen -t rsa -C &#x27;email&#x27; // Email可选，会在key中生成你的邮箱信息 一直回车就行 ​ 生成的 key 文件 C:\\Users\\你的用户名\\.ssh\\id_rsa.pub ​ 用文本编辑器打开，复制到 GIT 上。 # 3. 上传项目到 GIT 123456cd 项目文件加夹git initgit remote add origin git@github.com:fairyeye/StudyJava.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master # MySQL 安装 安装 https://www.runoob.com/mysql/mysql-install.html 修改初始密码 MySQL 版本 5.7.6 版本以前用户可以使用如下命令： 1mysql&gt; SET PASSWORD = PASSWORD(&#x27;your pwd&#x27;); MySQL 版本 5.7.6 版本开始的用户可以使用如下命令： 1mysql&gt; ALTER USER USER() IDENTIFIED BY &#x27;your pwd&#x27;; 登录报错 https://www.cnblogs.com/lifan1998/p/9177731.html # 去图标 ​ 管理员运行 去图标.bat 文件。 # 谷歌访问助手 ​ 谷歌浏览器 -&gt; 更多工具 -&gt; 扩展程序 -&gt; 开发者模式 (打开) 。 ​ 拖动 谷歌访问助手.crx 到谷歌浏览器中。 # 软件安装清单 IDEA： Chrome： uTools： Typora： Another Redis Desktop Manager：很好看的 Redis 客户端 XShell：好看 好用 tabby-terminal：https://github.com/Eugeny/tabby/releases/tag/v1.0.164 Shadowsocks：小飞机 Windows Termial:Windows 终端 nvm: Windows 切换 node 版本 n：Mac 切换 node 版本 pyenv：切换 python 版本 Invoke-WebRequest -UseBasicParsing -Uri &quot;https://raw.githubusercontent.com/pyenv-win/pyenv-win/master/pyenv-win/install-pyenv-win.ps1&quot; -OutFile &quot;./install-pyenv-win.ps1&quot;; &amp;&quot;./install-pyenv-win.ps1&quot; # Mac # 终端： # oh my zsh 12https://zhuanlan.zhihu.com/p/550022490https://blog.csdn.net/weixin_42326144/article/details/121957795","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://fairyeye.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[]},{"title":"Transactional注解","slug":"事务问题","date":"2023-06-05T05:49:50.604Z","updated":"2023-06-05T05:49:50.604Z","comments":true,"path":"2023/06/05/事务问题/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法 A 中调用 B 后再调用 C, 三个方法中均有插入数据后再查询数据 B 方法的注解：@Transactional (propagation=Propagation.REQUIRES_NEW) -- 不管是否存在事务，都创建一个新的事务，原来的挂起，新的执行完毕，继续执行老的事务 C 方法的注解：@Transactional (propagation=Propagation.REQUIRED) -- 如果有事务，那么加入事务，没有的话新建一个 1、当方法 B 或者 C 报错时，A、B、C 方法都回滚 2、当方法 A、B、C 异常被捕获时，A、B、C 事务不回滚（a、b、c 均入库） 3、当方法 BC 执行后，方法 A 报错时，A、C 事务回滚，B 事务不回滚（b 数据入库） A 方法向表中添加数据 a，在查询该表能得到数据 a B 方法向表中添加数据 b，再查询该表能得到数据 b C 方法向表中添加数据 c，再查询该表能得到数据 a，b，c 带有注解 @Transactional (propagation=Propagation.REQUIRES_NEW) 的方法走完之后，数据就会被提交入库 另外需要注意方法内部调用 @Transactional (propagation=Propagation.REQUIRES_NEW) 注解不生效，比如 A 和 B 都在同一个方法中，A 调用 B，B 方法是此注解，则不生效。同样，AOP 拦截也拦截不到 B 12345678910111213141516171819public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6); private final int value; private Propagation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; 七种事物传播类型 默认为： REQUIRED","categories":[{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"Sql小技巧","slug":"分页查询","date":"2023-06-05T05:49:50.604Z","updated":"2023-06-05T05:49:50.605Z","comments":true,"path":"2023/06/05/分页查询/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行。 123456789# 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;# 说明task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万 # 获取一条数据时的 Limit 1 在很多情况下我们已知数据仅存在一条，此时我们应该告知数据库只用查一条，否则将会转化为全表扫描 123456789# 反例（耗时2424.612s）select * from task_result where unique_key = &#x27;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#x27;;# 正例（耗时1.036s）select * from task_result where unique_key = &#x27;ebbf420b65d95573db7669f21fa3be3e_861414030800727_48&#x27; LIMIT 1;# 说明task_result表为生产环境的一个表，总数据量为3400万，where条件非索引字段，数据所在行为第19486条记录 # 批量插入 1234567891011# 反例INSERT into person(name,age) values(&#x27;A&#x27;,24)INSERT into person(name,age) values(&#x27;B&#x27;,24)INSERT into person(name,age) values(&#x27;C&#x27;,24)# 正例INSERT into person(name,age) values(&#x27;A&#x27;,24),(&#x27;B&#x27;,24),(&#x27;C&#x27;,24);# 说明比较常规，就不多做说明了 https://juejin.im/post/5ea16dede51d45470b4ffc5b?utm_source=gold_browser_extension","categories":[{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://fairyeye.github.io/tags/mysql/"}]},{"title":"Springboot","slug":"Springboot返回html","date":"2023-06-05T05:49:50.603Z","updated":"2023-06-05T06:02:36.940Z","comments":true,"path":"2023/06/05/Springboot返回html/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Springboot%E8%BF%94%E5%9B%9Ehtml/","excerpt":"","text":"# Springboot 返回 html 注：Springboot 的版本 2.1.3.RELEASE List-1 application.properties 文件 1234567server.port=8080#url中，项目的前缀server.servlet.context-path=/projectspring.mvc.view.prefix=/spring.mvc.view.suffix=.html 整体结构如下图 1 所示，html 要放在 static 下，不是 templates 下 图１ List-2 HelloController 的内容如下 1234567891011121314import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Slf4j@Controllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;) public String index() &#123; log.info(&quot;收到请求&quot;); return &quot;html/hello&quot;; &#125;&#125; List-3 启动 springboot，之后在浏览器中输入 12345#返回index.html的内容http://localhost:8080/project/#返回hello.html的内容http://localhost:8080/project/hello 网上很多关于模板的（Thymeleaf 、FreeMarker 等），但是我不需要，我只需要纯的 html。 index.html 是 springboot 的默认 welcome page。 # Reference https://www.jianshu.com/p/eb4c0fc2dfc4 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-static-content https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-welcome-page ​ (adsbygoogle = window.adsbygoogle || []).push({});","categories":[],"tags":[{"name":"基础","slug":"基础","permalink":"https://fairyeye.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"StringToInteger","slug":"StringToInteger","date":"2023-06-05T05:49:50.603Z","updated":"2023-06-05T05:49:50.603Z","comments":true,"path":"2023/06/05/StringToInteger/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/StringToInteger/","excerpt":"","text":"# String 转 Integer # 1.Integer 的 parseInt 方法 12345String string = &quot;123&quot;;int value = Integer.parseInt(string);System.out.println(&quot;stringToInt----------&gt;&quot;+value);结果：StringToInt----------&gt;123 # 2.Integer 的 valueOf 方法 12345String string = &quot;123&quot;;Integer value = Integer.valueOf(string);System.out.println(&quot;stringToInt1----------&gt;&quot;+value);结果：StringToInt1----------&gt;123 以上两种方法都是可行的。 但是会有特殊的情况，比如： 1234567891011String string = &quot;abc&quot;;int value = Integer.parseInt(string);System.out.println(&quot;stringToInt----------&gt;&quot;+value);结果：Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;abc&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.parseInt(Integer.java:615) at com.hand.todo.infra.util.StringToInt.stringToInt(StringToInt.java:16) at com.hand.todo.infra.util.StringToInt.main(StringToInt.java:10) 使用 stringToInt1 () 也会返回同样的错误。 123public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125; valueOf () 调用了 parseInt ()，所以返回同样的错误是正常的。 按照正常的逻辑来说，我们需要对这个错误进行处理，比如： 1234567891011121314151617String string = &quot;abc&quot;;int value = 0;try &#123; value = Integer.parseInt(string);&#125; catch (NumberFormatException e) &#123; e.printStackTrace();&#125;System.out.println(&quot;StringToInt----------&gt;&quot;+value);结果：java.lang.NumberFormatException: For input string: &quot;abc&quot; at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.parseInt(Integer.java:615) at com.hand.todo.infra.util.StringToInt.stringToInt(StringToInt.java:18) at com.hand.todo.infra.util.StringToInt.main(StringToInt.java:10)StringToInt----------&gt;0 可以看到，虽然依然报错，但是程序还是继续执行了。 然后回到主题。 # 3.Guava 的 Ints 结合 Java8 的 Optional 1234567String string = &quot;abc&quot;;Integer value = Optional.ofNullable(string) .map(Ints::tryParse) .orElse(0); System.out.println(&quot;StringToInt2----------&gt;&quot; + value); 结果：StringToInt2----------&gt;0 可以在转换失败的时候为他设置默认值： 1234567String string = &quot;abc&quot;;Integer value = Optional.ofNullable(string) .map(Ints::tryParse) .orElse(100); System.out.println(&quot;StringToInt2----------&gt;&quot; + value); 结果：StringToInt2----------&gt;100 写在末尾：之所以写这么详细是因为最开始的时候我很菜，看别人写的文档都很简单，虽然可以解决问题，但是却不解其意，所以写的啰嗦一点，对新手比较友好。 ​ &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"java","slug":"java","permalink":"https://fairyeye.github.io/categories/java/"}],"tags":[]},{"title":"需要掌握以下知识","slug":"需要掌握以下知识","date":"2023-06-05T05:49:50.603Z","updated":"2023-06-05T06:01:13.588Z","comments":true,"path":"2023/06/05/需要掌握以下知识/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E4%BB%A5%E4%B8%8B%E7%9F%A5%E8%AF%86/","excerpt":"","text":"导入数据 匹配规则 3. 生成报告和数据 作为一名三年经验的 Java 开发人员，你需要掌握以下知识： Java 基础知识：掌握 Java 的基本语法、面向对象编程、常用数据结构和算法等，能够熟练使用 Java 语言进行开发。 Java Web 开发框架：熟悉 Spring、SpringMVC 和 MyBatis 等主流的 Java Web 开发框架，能够使用这些框架进行 Web 应用程序的开发。 数据库知识：熟悉关系型数据库和 NoSQL 数据库的使用，掌握 SQL 语言和数据库设计的基本知识。 Web 前端技术：熟悉 HTML、CSS、JavaScript、jQuery 等前端开发技术，能够与前端开发人员协同工作，完成 Web 应用程序的前后端分离开发。 网络编程知识：熟悉 TCP/IP 协议、HTTP 协议等网络编程相关的知识，能够使用 Java 进行网络编程开发。 分布式系统开发：了解分布式系统的基本概念和原理，熟悉 Spring Cloud、Dubbo 等分布式系统开发框架，能够进行分布式系统的设计和开发。 微服务架构：了解微服务架构的基本概念和原理，熟悉 Spring Boot、Spring Cloud 等微服务开发框架，能够进行微服务的设计和开发。 工具和技术：掌握 Maven、Git、Jenkins 等常用的工具和技术，能够进行代码管理、构建和部署。 技术栈扩展：根据自身的兴趣和职业发展需求，了解其他的 Java 技术栈，例如大数据处理、人工智能、区块链等，不断扩展自己的技术领域。 除了以上技术知识，你还需要具备良好的团队协作能力、学习能力和解决问题的能力，能够快速适应不同的项目需求和开发环境，不断提升自己的技术水平和职业素养。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://fairyeye.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"List stream","slug":"Java 8 Stream","date":"2023-06-05T05:49:50.602Z","updated":"2023-06-05T05:49:50.602Z","comments":true,"path":"2023/06/05/Java 8 Stream/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Java%208%20Stream/","excerpt":"","text":"通过 workOrederNum 字段排序 1List&lt;ProduceOrderDTO&gt; collect = list.stream().sorted(Comparator.comparing(ProduceOrderDTO::getWorkOrderNum)).collect(Collectors.toList()); 查出 InstructionPoDTO 中 InstructionDocNum 作为 list 12// 筛选出不重复的 instructionDocNumList&lt;String&gt; instructionDocNums = read.stream().map(InstructionPoDTO::getInstructionDocNum).distinct().collect(Collectors.toList()); 筛选所有 instructionDocNum = 123 的对象 12List&lt;InstructionPoDTO&gt; instructionPoDTOS = read.stream().filter(instructionPoDTO -&gt; instructionPoDTO.getInstructionDocNum().equals(&quot;123&quot;)).collect(Collectors.toList()); 查询出第一个 1String instructionDocId = instructionDocs.stream().findFirst().get(); 设置 typeCode 为 key， list 的对象为 value 1Map&lt;String, MtGenType&gt; typesMap = types.stream().collect(Collectors.toMap(t -&gt; t.getTypeCode(), t -&gt; t)); // 通过字段去重 1instructionSapStockDTOS.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(()-&gt; new TreeSet&lt;&gt;(Comparator.comparing(o -&gt; o.getMaterial()+&quot;;&quot;+o.getPlant()+&quot;;&quot;+o.getStorage()+&quot;;&quot;+o.getBatch()+&quot;;&quot;+o.getSpecialStock()))), ArrayList::new)); GROUP BY 123456789101112131415161718192021222324252627Map&lt;String, List&lt;WmsIqcRecord&gt;&gt; map = records.stream().collect(Collectors.groupingBy(iqcRecord -&gt; &#123; if (StringUtils.equals(&quot;TO_DO&quot;, iqcRecord.getStatus())) &#123; switch (iqcRecord.getDealMethod()) &#123; case &quot;RELEASE&quot;: return &quot;TO_RELEASE&quot;; case &quot;FREEZE&quot;: return &quot;TO_FREEZE&quot;; case &quot;RETURN&quot;: return &quot;TO_RETURN&quot;; default: return &quot;TO_DO&quot;; &#125; &#125; else if (StringUtils.equals(&quot;DONE&quot;, iqcRecord.getStatus())) &#123; switch (iqcRecord.getDealMethod()) &#123; case &quot;RELEASE&quot;: return &quot;RELEASE_DONE&quot;; case &quot;FREEZE&quot;: return &quot;FREEZE_DONE&quot;; case &quot;RETURN&quot;: return &quot;RETURN_DONE&quot;; default: return &quot;DONE&quot;; &#125; &#125; else &#123; return &quot;DEAL&quot;; &#125; &#125;)); 1234567// List&lt;LocalDate&gt; collect = localDates.stream().sorted((var1, var2) -&gt; &#123;// if (var1.isBefore(var2)) &#123;// return -1;// &#125;// return 1;// &#125;).collect(Collectors.toList());// System.out.println(localDates.stream().sorted().collect(Collectors.toList()));","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://fairyeye.github.io/tags/Java/"}]},{"title":"MySQL","slug":"MySQL","date":"2023-06-05T05:49:50.602Z","updated":"2023-06-05T05:49:50.602Z","comments":true,"path":"2023/06/05/MySQL/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/MySQL/","excerpt":"","text":"123456789101112SELECT swid.OPERATION, swid.DELIVERY_METHOD, GROUP_CONCAT( DISTINCT( swid.WORK_ORDER_ID ) ) WORK_ORDER_ID FROM SSME_WO_ISSUE_DETAIL swid WHERE swid.TENANT_ID = 4 AND swid.WORK_ORDER_ID IN ( &#x27;42717.1&#x27;,&#x27;42719.1&#x27; ) GROUP BY swid.OPERATION, swid.DELIVERY_METHOD https://www.cnblogs.com/minqiliang/p/16577102.html https://blog.csdn.net/z15711187787/article/details/124986309 https://blog.csdn.net/weixin_45994575/article/details/123071909?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123071909-blog-123821186.t0_edu_mix&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-123071909-blog-123821186.t0_edu_mix&amp;utm_relevant_index=1 部署记录 # JDBCTemplete 批处理 123456789101112131415161718// sql语句String sql = &quot;INSERT INTO ssme_iqc_change(TENANT_ID, KID) VALUE (?, ?);&quot;;List&lt;String&gt; kids = new ArrayList&lt;&gt;();// BatchPreparedStatementSetter 通过循环取出数据填充到SQL中jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() &#123; @Override public void setValues(PreparedStatement ps, int i) throws SQLException &#123; ps.setLong(1, 4L); ps.setString(2, kids.get(i)); &#125; @Override public int getBatchSize() &#123; return kids.size(); &#125; &#125;); # MySQL 数据删除恢复 123456# 数据库中运行# 判断binlog是否开启show variables like &#x27;%log_bin%&#x27;;# 找到数据库data位置show variables like &#x27;datadir&#x27;; data 目录下数据 找到当天的 binlog 12# 转换为SQL 只转换操作时间内的数据即可root@VM-4-10-ubuntu:/var/lib/mysql# mysqlbinlog --base64-output=decode-rows -v --database=smart-admin-dev --start-datetime=&quot;2022-11-28 10:50:00&quot; --stop-datetime=&quot;2022-11-28 11:00:00&quot; binlog.000018 &gt; 000018.sql 000018.sql 12# 将SQL转换为insert语句root@VM-4-10-ubuntu:/var/lib/mysql# cat 000018.sql | sed -n &#x27;/###/p&#x27; | sed &#x27;s/### //g;s/\\/\\*.*/,/g;s/DELETE FROM/;INSERT INTO/g;s/WHERE/SELECT/g;&#x27; |sed -r &#x27;s/(@17.*),/\\1;/g&#x27; | sed &#x27;s/@1=//g&#x27;| sed &#x27;s/@[1-9]=/,/g&#x27; | sed &#x27;s/@[1-9][0-9]=/,/g&#x27; &gt; 000018OK.sql 000018OK.sql 最后将数据导入数据库即可。 # Group 123-- 修改 group_concat 长度限制SET GLOBAL group_concat_max_len=102400;SET SESSION group_concat_max_len=102400; # Mapper 空指针 count sql resultType 为对象，导致报错","categories":[{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"Nacos","slug":"Nacos","date":"2023-06-05T05:49:50.602Z","updated":"2023-06-05T05:49:50.602Z","comments":true,"path":"2023/06/05/Nacos/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Nacos/","excerpt":"","text":"# 配置中心 # 1. 添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.1&lt;/version&gt; &lt;/dependency&gt; # 2. 启动类注解 @NacosPropertySource 12345678910@SpringBootApplication // dataId 对应配置管理-配置列表-dataId@NacosPropertySource(dataId = &quot;nacosDemo&quot;, autoRefreshed = true) public class NacosDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosDemoApplication.class, args); &#125; &#125; # 3. 配置 nacos 地址 123spring: application: name: nacos-demo # 4. 使用配置 123456789101112131415@RestController public class CacheController &#123; @NacosValue(value = &quot;$&#123;useLocalCache:false&#125;&quot;, autoRefreshed = true) private boolean useLocalCache; private static final String template = &quot;useLocalCache is %s!&quot;; @GetMapping(&quot;/cache&quot;) public String cache() &#123; // 默认返回false return String.format(template, useLocalCache); &#125; &#125;// 此时返回结果 ：useLocalCache is false! 增加配置并发布 1// 返回结果 ：useLocalCache is true!","categories":[{"name":"中间件","slug":"中间件","permalink":"https://fairyeye.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[]},{"title":"","slug":"FileUtils","date":"2023-06-05T05:49:50.601Z","updated":"2023-06-05T05:49:50.601Z","comments":true,"path":"2023/06/05/FileUtils/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/FileUtils/","excerpt":"","text":"# title: 工具类 date: 2020-04-20 11:00:50 categories: &quot;工具类&quot; # 数组转文件 123456789101112131415161718192021222324252627282930313233343536373839/** * @param bfile * @param filePath * @param fileName * * 根据byte数组，生成文件 */public static void getFile(byte[] bfile, String filePath,String fileName) &#123; BufferedOutputStream bos = null; FileOutputStream fos = null; File file = null; try &#123; File dir = new File(filePath); if(!dir.exists()&amp;&amp;dir.isDirectory())&#123;//判断文件目录是否存在 dir.mkdirs(); &#125; file = new File(filePath+&quot;\\\\&quot;+fileName); fos = new FileOutputStream(file); bos = new BufferedOutputStream(fos); bos.write(bfile); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (bos != null) &#123; try &#123; bos.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Delete/Truncate/Drop","slug":"Delete & Truncate","date":"2023-06-05T05:49:50.601Z","updated":"2023-06-05T05:49:50.601Z","comments":true,"path":"2023/06/05/Delete & Truncate/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Delete%20&%20Truncate/","excerpt":"","text":"假如把一张表比作一间教室，数据比作学生。 drop 就是把这件教师炸掉了，教室都没了，更不用说数据了。 truncate 就是把学生开除了，离开了，再也没有了。 delete 就是学生出去了，虽然他们可能不会回来了，但是位置还是要留着。 # Drop 直接删掉表，这个没什么好说的。 包括表结构，表数据，全部删除，占用的空间也会释放。 # Truncate 截断表，会释放空间。 # Delete 删除数据","categories":[],"tags":[{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"}]},{"title":"反射","slug":"反射获取父类字段","date":"2023-06-05T01:28:10.956Z","updated":"2023-06-05T01:28:10.956Z","comments":true,"path":"2023/06/05/反射获取父类字段/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E5%AD%97%E6%AE%B5/","excerpt":"","text":"1234Class&lt;?&gt; superclass = itfBaseBO.getClass();while (!superclass.getName().equals(ExpandDomain.class.getName())) &#123; superclass = superclass.getSuperclass();&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fairyeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"demo","slug":"demo","permalink":"https://fairyeye.github.io/tags/demo/"}]},{"title":"Ubuntu","slug":"Ubuntu","date":"2023-06-05T01:28:10.953Z","updated":"2023-06-20T03:10:15.300Z","comments":true,"path":"2023/06/05/Ubuntu/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Ubuntu/","excerpt":"","text":"# NETDATA # 1. 安装编译环境 1sudo apt install zlib1g-dev gcc make git autoconf autogen automake pkg-config uuid-dev # 2. 克隆项目 1git clone https://github.com/firehol/netdata.git --depth=1 # 3. 安装 netdata 123456https://www.cnblogs.com/beile/p/12875395.html官方：https://learn.netdata.cloud/docs/agent/packaging/installer/methods/offline./netdata-installer.sh 然后访问 IP:19999 # NGINX # 1. 安装 Nginx 12sudo suapt-get install nginx 浏览器地址栏输入 IP 看到如下页面表示已经安装好了 Nginx，如果有域名，输入域名也是同样的效果（前提是已经给域名添加了解析） # 2.Nginx 转发端口 我已经在服务器上安装了 netdata 服务，端口为 19999 , 但是通过 Nginx 访问服务器时默认是 80 端口，所以需要做一些配置，在我们输入域名的时候访问不同的端口。 123456789101112131415161718192021# nginx.conf里包含 include /etc/nginx/conf.d/*.conf; 所以可以在/etc/nginx/conf.d 文件夹下新增一个配置文件server &#123; listen 80; server_name IP; location / &#123; client_max_body_size 3000m; proxy_next_upstream http_502 http_504 error timeout invalid_header; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:19999; proxy_redirect default; proxy_connect_timeout 3000; &#125;&#125; 这样 当我们在浏览器地址栏输入 域名时 就会自动跳转到 netdata 的主页 # 3. 反向代理 + 负载均衡 =&gt; 12345678910111213141516171819202122# 实际服务upstream web_servers &#123; server 192.168.139.128:9001; server 192.168.139.128:9002;&#125;server &#123; # 代理端口 listen 10086; server_name 192.168.139.128; location / &#123; proxy_pass http://web_servers; proxy_set_header Host $host:$server_port; &#125;&#125;# 可以部署两个服务 9001、9002 发布时，等上一个成功发布后，启动第二个。# 未验证# 加上systemclt管理Java服务# 负载均衡的方式：https://mp.weixin.qq.com/s/yJyEwPkLD0V9G0451gbZYg# 1.轮询；2.权重；3.ip_hash；4.fair；5.url_hash # 时区 - https://blog.csdn.net/weixin_44109450/article/details/124259338 - # Github sudo vim /etc/hosts 140.82.112.4 github.com 199.232.69.194 github.global.ssl.fastly.net # 内网穿透 121. https://doc.natfrp.com/#/frpc/service/systemd2. # 青龙 12# 进入青龙容器docker exec -it qinglong bash # 使用 systemctl 管理服务 12345678https://www.jianshu.com/p/2deb0b79cb10# 路径/etc/systemd/system# 日志journalctl -u 服务名 # Arthas 123456789101112131415161718192021https://arthas.aliyun.com/doc/quick-start.html#_2-%E5%90%AF%E5%8A%A8-arthas[arthas@588425]$ watch net.lab1024.smartadmin.module.business.project.service.ProjectBaiscService queryProjects returnObjPress Q or Ctrl+C to abort.Affect(class count: 2 , method count: 2) cost in 170 ms, listenerId: 1method=net.lab1024.smartadmin.module.business.project.service.ProjectBaiscService.queryProjects location=AtExitts=2022-11-28 20:11:49; [cost=37.212667ms] result=@ResponseDTO[ code=@Integer[1], msg=@String[操作成功!], success=@Boolean[true], data=@ArrayList[isEmpty=false;size=13],]method=net.lab1024.smartadmin.module.business.project.service.ProjectBaiscService$$EnhancerBySpringCGLIB$$2f00139f.queryProjects location=AtExitts=2022-11-28 20:11:49; [cost=94.21994ms] result=@ResponseDTO[ code=@Integer[1], msg=@String[操作成功!], success=@Boolean[true], data=@ArrayList[isEmpty=false;size=13],] # Prometheus 123456789101112131415161718192021222324# prometheuswget https://github.com/prometheus/prometheus/releases/download/v2.40.4/prometheus-2.40.4.linux-amd64.tar.gztar -zxvf prometheus-2.40.4.linux-amd64.tar.gzsudo mv prometheus-2.40.4.linux-amd64 /usr/local/prometheusvim /usr/lib/systemd/system/prometheus.service[Unit]Description=prometheusAfter=network.target [Service]User=prometheusGroup=prometheusWorkingDirectory=/usr/local/prometheusExecStart=/usr/local/prometheus/prometheus[Install]WantedBy=multi-user.target# 启动并开启自启systemctl daemon-reloadsystemctl enable --now prometheus # 123456789101112131415161718192021222324cd ~/gitee_go/deoloylstar -zxf output.tar.gzcd targetpid=`ps -ef|grep xxx|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;`if [ $pid ]then kill -15 $pid finohup java -jar xxx.jar --server.port=8090 &amp;# Ubuntu sh脚本不支持for循环 这里会报错for((i=1;i&lt;=10;i++));do new_pid=`ps -ef|grep xxx|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;` if [ ! $new_pid ] then echo &#x27;starting......&#x27; sleep 10 else echo &quot;Deploy Success&quot; break; fidone","categories":[],"tags":[{"name":"系统集成","slug":"系统集成","permalink":"https://fairyeye.github.io/tags/%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90/"}]},{"title":"Jmeter","slug":"Jmeter简单使用","date":"2023-06-05T01:28:10.950Z","updated":"2023-06-05T06:02:13.637Z","comments":true,"path":"2023/06/05/Jmeter简单使用/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Jmeter%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"https://fairyeye.github.io/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Navicat数据库导出链接密码解析","slug":"Mac 数据库忘记密码","date":"2023-06-05T01:28:10.950Z","updated":"2023-06-05T01:28:10.950Z","comments":true,"path":"2023/06/05/Mac 数据库忘记密码/","link":"","permalink":"https://fairyeye.github.io/2023/06/05/Mac%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/","excerpt":"","text":"参考：https://blog.csdn.net/harris_lele/article/details/123588127 导出来，然后用 php 解析密码即可； 在线运行 php： https://www.toolfk.com/tools/online-runphp.html 运行代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;?phpclass NavicatPassword&#123; protected $version = 0; protected $aesKey = &#x27;libcckeylibcckey&#x27;; protected $aesIv = &#x27;libcciv libcciv &#x27;; protected $blowString = &#x27;3DC5CA39&#x27;; protected $blowKey = null; protected $blowIv = null; public function __construct($version = 12) &#123; $this-&gt;version = $version; $this-&gt;blowKey = sha1(&#x27;3DC5CA39&#x27;, true); $this-&gt;blowIv = hex2bin(&#x27;d9c7c3c8870d64bd&#x27;); &#125; public function encrypt($string) &#123; $result = FALSE; switch ($this-&gt;version) &#123; case 11: $result = $this-&gt;encryptEleven($string); break; case 12: $result = $this-&gt;encryptTwelve($string); break; default: break; &#125; return $result; &#125; protected function encryptEleven($string) &#123; $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = &#x27;&#x27;; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) &#123; $temp = $this-&gt;encryptBlock($this-&gt;xorBytes(substr($string, 8 * $i, 8), $currentVector)); $currentVector = $this-&gt;xorBytes($currentVector, $temp); $result .= $temp; &#125; if ($leftLength) &#123; $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); &#125; return strtoupper(bin2hex($result)); &#125; protected function encryptBlock($block) &#123; return openssl_encrypt($block, &#x27;BF-ECB&#x27;, $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); &#125; protected function decryptBlock($block) &#123; return openssl_decrypt($block, &#x27;BF-ECB&#x27;, $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); &#125; protected function xorBytes($str1, $str2) &#123; $result = &#x27;&#x27;; for ($i = 0; $i &lt; strlen($str1); $i++) &#123; $result .= chr(ord($str1[$i]) ^ ord($str2[$i])); &#125; return $result; &#125; protected function encryptTwelve($string) &#123; $result = openssl_encrypt($string, &#x27;AES-128-CBC&#x27;, $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); return strtoupper(bin2hex($result)); &#125; public function decrypt($string) &#123; $result = FALSE; switch ($this-&gt;version) &#123; case 11: $result = $this-&gt;decryptEleven($string); break; case 12: $result = $this-&gt;decryptTwelve($string); break; default: break; &#125; return $result; &#125; protected function decryptEleven($upperString) &#123; $string = hex2bin(strtolower($upperString)); $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = &#x27;&#x27;; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) &#123; $encryptedBlock = substr($string, 8 * $i, 8); $temp = $this-&gt;xorBytes($this-&gt;decryptBlock($encryptedBlock), $currentVector); $currentVector = $this-&gt;xorBytes($currentVector, $encryptedBlock); $result .= $temp; &#125; if ($leftLength) &#123; $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); &#125; return $result; &#125; protected function decryptTwelve($upperString) &#123; $string = hex2bin(strtolower($upperString)); return openssl_decrypt($string, &#x27;AES-128-CBC&#x27;, $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); &#125;&#125;; //需要指定版本两种，11或12//$navicatPassword = new NavicatPassword(11);$navicatPassword = new NavicatPassword(12); //解密//$decode = $navicatPassword-&gt;decrypt(&#x27;15057D7BA390&#x27;);$decode = $navicatPassword-&gt;decrypt(&#x27;75008D0AE102C19EE3767E201AC9E4D2&#x27;);echo $decode.&quot;\\n&quot;;?&gt;","categories":[{"name":"实用","slug":"实用","permalink":"https://fairyeye.github.io/categories/%E5%AE%9E%E7%94%A8/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法","slug":"算法","date":"2023-02-13T08:12:42.000Z","updated":"2023-06-05T05:49:50.606Z","comments":true,"path":"2023/02/13/算法/","link":"","permalink":"https://fairyeye.github.io/2023/02/13/%E7%AE%97%E6%B3%95/","excerpt":"","text":"# LFU (最不经常使用缓存) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.*;public class LFUCache&lt;K, V&gt; &#123; private final int capacity; private Map&lt;K, V&gt; cache; private Map&lt;K, Integer&gt; freqMap; private Map&lt;Integer, LinkedHashSet&lt;K&gt;&gt; freqKeysMap; private int minFreq; public LFUCache(int capacity) &#123; this.capacity = capacity; cache = new HashMap&lt;&gt;(); freqMap = new HashMap&lt;&gt;(); freqKeysMap = new HashMap&lt;&gt;(); minFreq = 0; &#125; public V get(K key) &#123; if (!cache.containsKey(key)) &#123; return null; &#125; int freq = freqMap.get(key); freqMap.put(key, freq + 1); freqKeysMap.get(freq).remove(key); if (freq == minFreq &amp;&amp; freqKeysMap.get(freq).size() == 0) &#123; minFreq++; &#125; if (!freqKeysMap.containsKey(freq + 1)) &#123; freqKeysMap.put(freq + 1, new LinkedHashSet&lt;&gt;()); &#125; freqKeysMap.get(freq + 1).add(key); return cache.get(key); &#125; public void put(K key, V value) &#123; if (capacity &lt;= 0) &#123; return; &#125; if (cache.containsKey(key)) &#123; cache.put(key, value); get(key); return; &#125; if (cache.size() &gt;= capacity) &#123; K evictKey = freqKeysMap.get(minFreq).iterator().next(); freqKeysMap.get(minFreq).remove(evictKey); cache.remove(evictKey); freqMap.remove(evictKey); &#125; cache.put(key, value); freqMap.put(key, 1); minFreq = 1; if (!freqKeysMap.containsKey(1)) &#123; freqKeysMap.put(1, new LinkedHashSet&lt;&gt;()); &#125; freqKeysMap.get(1).add(key); &#125;&#125; LFU 缓存在处理缓存置换的时候会考虑到访问频率的因素。如果缓存空间已满，那么就要淘汰掉一些数据，以腾出空间存放新的数据。常见的淘汰算法有：先进先出（First In First Out，FIFO）、最近最少使用（Least Recently Used，LRU）和最不经常使用（Least Frequently Used，LFU）等。 这里我们实现了一个 LFU Cache，使用三个 Map 来存储缓存数据，缓存键的访问频率，以及不同访问频率下对应的缓存键集合。具体实现中，我们使用一个 minFreq 变量来记录当前最小访问频率，并在每次访问或插入数据时更新 minFreq。当缓存空间已满时，我们根据 minFreq 和缓存键集合中的顺序来选择要淘汰的数据。 该实现中，get 和 put 操作的时间复杂度均为 O (1)。如果需要支持高并发操作，可以在实现中加入线程安全机制。","categories":[],"tags":[{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"}]},{"title":"搭建SSR服务器","slug":"搭建SSR服务器","date":"2022-12-07T03:00:24.000Z","updated":"2023-06-05T05:49:50.606Z","comments":true,"path":"2022/12/07/搭建SSR服务器/","link":"","permalink":"https://fairyeye.github.io/2022/12/07/%E6%90%AD%E5%BB%BASSR%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435apt install git 报错：Temporary failure resolving &#x27;archive.ubuntu.com具体如下：Ign:1 http://archive.ubuntu.com/ubuntu xenial/main i386 liberror-perl all 0.17-1.2Ign:2 http://archive.ubuntu.com/ubuntu xenial/main i386 git-man all 1:2.7.4-0ubuntu1Err:3 http://archive.ubuntu.com/ubuntu xenial/main amd64 git amd64 1:2.7.4-0ubuntu1 Temporary failure resolving &#x27;archive.ubuntu.com&#x27;Err:1 http://archive.ubuntu.com/ubuntu xenial/main i386 liberror-perl all 0.17-1.2 Temporary failure resolving &#x27;archive.ubuntu.com&#x27;Err:2 http://archive.ubuntu.com/ubuntu xenial/main i386 git-man all 1:2.7.4-0ubuntu1 Temporary failure resolving &#x27;archive.ubuntu.com&#x27;E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/main/libe/liberror-perl/liberror-perl_0.17-1.2_all.deb Temporary failure resolving &#x27;archive.ubuntu.com&#x27;E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/main/g/git/git-man_2.7.4-0ubuntu1_all.deb Temporary failure resolving &#x27;archive.ubuntu.com&#x27;E: Failed to fetch http://archive.ubuntu.com/ubuntu/pool/main/g/git/git_2.7.4-0ubuntu1_amd64.deb Temporary failure resolving &#x27;archive.ubuntu.com&#x27;E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing?root@132157:~# apt-get updateErr:1 http://security.ubuntu.com/ubuntu xenial-security InRelease Temporary failure resolving &#x27;security.ubuntu.com&#x27;Err:2 http://archive.ubuntu.com/ubuntu xenial InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;Err:3 http://archive.ubuntu.com/ubuntu xenial-updates InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;Err:4 http://archive.ubuntu.com/ubuntu xenial-backports InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;Reading package lists... DoneW: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial/InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial-updates/InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/xenial-backports/InRelease Temporary failure resolving &#x27;archive.ubuntu.com&#x27;W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/xenial-security/InRelease Temporary failure resolving &#x27;security.ubuntu.com&#x27;W: Some index files failed to download. They have been ignored, or old ones used instead. 原因是DNS未配置 1234sudo vi /etc/resolv.conf+ nameserver 202.96.134.133+ nameserver 8.8.8.8","categories":[{"name":"杂项","slug":"杂项","permalink":"https://fairyeye.github.io/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"others","slug":"others","permalink":"https://fairyeye.github.io/tags/others/"}]},{"title":"Redis笔记","slug":"Redis","date":"2021-12-10T02:36:33.000Z","updated":"2023-06-05T05:49:50.603Z","comments":true,"path":"2021/12/10/Redis/","link":"","permalink":"https://fairyeye.github.io/2021/12/10/Redis/","excerpt":"","text":"// 201 个线程 应该扣减 201 -&gt; 库存不足","categories":[{"name":"中间件","slug":"中间件","permalink":"https://fairyeye.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://fairyeye.github.io/tags/redis/"}]},{"title":"数据库时间存储","slug":"数据库时间存储","date":"2020-04-29T08:12:42.000Z","updated":"2023-06-05T05:49:50.606Z","comments":true,"path":"2020/04/29/数据库时间存储/","link":"","permalink":"https://fairyeye.github.io/2020/04/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E9%97%B4%E5%AD%98%E5%82%A8/","excerpt":"","text":"# 数据库如何存储时间？你真的知道吗？ 我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现这个时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。 这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！ # 1. 切记不要用字符串存储日期 我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。 但是，这是不正确的做法，主要会有下面两个问题： 字符串占用的空间更大！ 字符串存储的日期比较效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。 # 2.Datetime 和 Timestamp 之间抉择 Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？ 通常我们都会首选 Timestamp。 下面说一下为什么这样做！ # 2.1 DateTime 类型没有时区信息的 DateTime 类型是没有时区信息的（时区无关） ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。 Timestamp 和时区有关。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。 下面实际演示一下！ 建表 SQL 语句： 123456CREATE TABLE `time_zone_test` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `date_time` datetime DEFAULT NULL, `time_stamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据： 1INSERT INTO time_zone_test(date_time,time_stamp) VALUES(NOW(),NOW()); 查看数据： 1select date_time,time_stamp from time_zone_test; 结果： 12345+---------------------+---------------------+| date_time | time_stamp |+---------------------+---------------------+| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |+---------------------+---------------------+ 现在我们运行 修改当前会话的时区: 1set time_zone=&#x27;+8:00&#x27;; 再次查看数据： 12345+---------------------+---------------------+| date_time | time_stamp |+---------------------+---------------------+| 2020-01-11 09:53:32 | 2020-01-11 17:53:32 |+---------------------+---------------------+ 扩展：一些关于 MySQL 时区设置的一个常用 sql 命令 12345678910# 查看当前会话时区SELECT @@session.time_zone;# 设置当前会话时区SET time_zone = &#x27;Europe/Helsinki&#x27;;SET time_zone = &quot;+00:00&quot;;# 数据库全局时区设置SELECT @@global.time_zone;# 设置全局时区SET GLOBAL time_zone = &#x27;+8:00&#x27;;SET GLOBAL time_zone = &#x27;Europe/Helsinki&#x27;; # 2.2 DateTime 类型耗费空间更大 Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。 DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59 Timestamp 在不同版本的 MySQL 中有细微差别。 # 3 再看 MySQL 日期类型存储空间 下图是 MySQL 5.6 版本中日期类型所占的存储空间： 可以看出 5.6.4 之后的 MySQL 多出了一个需要 0 ～ 3 字节的小数位。Datatime 和 Timestamp 会有几种不同的存储空间占用。 为了方便，本文我们还是默认 Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。 # 4. 数值型时间戳是更好的选择吗？ 很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。 这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。 时间戳的定义如下： 时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。 数据库中实际操作： 123456789101112131415mysql&gt; select UNIX_TIMESTAMP(&#x27;2020-01-11 09:53:32&#x27;);+---------------------------------------+| UNIX_TIMESTAMP(&#x27;2020-01-11 09:53:32&#x27;) |+---------------------------------------+| 1578707612 |+---------------------------------------+1 row in set (0.00 sec)mysql&gt; select FROM_UNIXTIME(1578707612);+---------------------------+| FROM_UNIXTIME(1578707612) |+---------------------------+| 2020-01-11 09:53:32 |+---------------------------+1 row in set (0.01 sec) 1转载：https://juejin.im/post/5e1d494a5188254c45778a14","categories":[],"tags":[{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"}]},{"title":"Go笔记","slug":"Go笔记","date":"2020-04-20T03:00:50.000Z","updated":"2023-06-05T05:49:50.601Z","comments":true,"path":"2020/04/20/Go笔记/","link":"","permalink":"https://fairyeye.github.io/2020/04/20/Go%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1// 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。 报错： The 'main' file has the non-main package or does not contain the 'main' function main 函数需要再 main 包下","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fairyeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"IDEA","slug":"IDEA","date":"2020-04-20T03:00:50.000Z","updated":"2023-06-05T05:49:50.602Z","comments":true,"path":"2020/04/20/IDEA/","link":"","permalink":"https://fairyeye.github.io/2020/04/20/IDEA/","excerpt":"","text":"# 1. Maven 设置 多 module 下，启动程序报错： 执行下，就可以了","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://fairyeye.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[]},{"title":"设计模式笔记","slug":"设计模式笔记","date":"2020-04-20T03:00:50.000Z","updated":"2023-06-05T05:49:50.607Z","comments":true,"path":"2020/04/20/设计模式笔记/","link":"","permalink":"https://fairyeye.github.io/2020/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"设计模式遵循六⼤原则；单⼀职责 (⼀个类和⽅法只做⼀件事)、⾥⽒替换 ( 多态，⼦类可扩展⽗类 )、依赖 倒置 ( 细节依赖抽象，下层依赖上层 )、接⼝隔离 ( 建⽴单⼀接⼝ )、迪⽶特原则 ( 最少知道，降低耦合 )、开闭 原则 ( 抽象架构，扩展实现 ）。 # 1. 工厂模式 举个例子： 吃：南方人爱吃饭，北方人爱吃面 定义一个接口：吃 定义两个实现类继承吃：饭、面 定义一个工厂：饭店 饭店通过判断是南方人还是北方人返回不同的实现类，从而让不同的人吃到了不同的饭 # 2. 抽象工厂模式 # 3. 建造者模式 实体类的 setXxx() 方法，一般是返回 void ，可以改造为： 1234public ObjectX setXxx(String xx) &#123; this.xxx = xx return this;&#125; # 4. 原型模式 考卷题目和答案乱序。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://fairyeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"阿里巴巴手册","slug":"阿里巴巴手册","date":"2020-04-20T03:00:50.000Z","updated":"2023-06-05T05:49:50.607Z","comments":true,"path":"2020/04/20/阿里巴巴手册/","link":"","permalink":"https://fairyeye.github.io/2020/04/20/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%89%8B%E5%86%8C/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"时间戳转换日期问题","slug":"时间戳转换日期问题","date":"2020-04-17T02:59:54.000Z","updated":"2023-06-05T05:49:50.606Z","comments":true,"path":"2020/04/17/时间戳转换日期问题/","link":"","permalink":"https://fairyeye.github.io/2020/04/17/%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2%E6%97%A5%E6%9C%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"# 基础依赖 后来发现是我拿到的时间戳是以 秒 为单位的，而转换时需要的是 毫秒。 1Date date = new Date(1579676844); // 1970-01-19T14:47:56.844+0800 1Date date = new Date(1579676844 * 1000L); // 2020-01-22T15:07:24.000+0800","categories":[],"tags":[{"name":"basic","slug":"basic","permalink":"https://fairyeye.github.io/tags/basic/"}]},{"title":"Hexo","slug":"15","date":"2020-04-15T06:34:30.000Z","updated":"2023-06-14T05:43:41.394Z","comments":true,"path":"2020/04/15/15/","link":"","permalink":"https://fairyeye.github.io/2020/04/15/15/","excerpt":"","text":"12345# hexo shokahttps://shoka.lostyu.me/computer-science/note/theme-shoka-doc/config/#%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA# 隐藏文章https://www.cnblogs.com/yangstar/articles/16690342.html","categories":[],"tags":[{"name":"hexo,theme,shoka","slug":"hexo-theme-shoka","permalink":"https://fairyeye.github.io/tags/hexo-theme-shoka/"}]},{"title":"内部类问题","slug":"14","date":"2020-04-14T01:41:32.000Z","updated":"2023-06-05T01:28:10.947Z","comments":true,"path":"2020/04/14/14/","link":"","permalink":"https://fairyeye.github.io/2020/04/14/14/","excerpt":"","text":"12错误描述信息：org.fairy.eye.domin.entity.User is not an enclosing class ​ 在 new 一个内部类的对象时，idea 会生成如下的代码。 12// Info 是User的内部类User.Info info = new User.Info(); ​ 然后会提示报错 org.fairy.eye.domin.entity.User is not an enclosing class ​ 如果内部类没有用 static 修饰的话，是不能这样 new 的。 ​ 需要有外部类实例对象来支持。 12User user = new User();User.Info info = new user.Info();","categories":[],"tags":[{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"}]},{"title":"GIT代码无法合并+本地构建成功服务器构建失败","slug":"13","date":"2020-04-13T01:13:28.000Z","updated":"2023-06-05T01:28:10.947Z","comments":true,"path":"2020/04/13/13/","link":"","permalink":"https://fairyeye.github.io/2020/04/13/13/","excerpt":"","text":"# 1.GIT 相关 # 场景： ​ GIT 版本出了点问题，无法正常合并代码 # 具体描述： ​ 由于误操作，导致我的本地分支和 dev 分支不同，在 GIT 上对比的时候显示无差别，但是实际上最近一次的提交是没有合并的。 ​ 无奈之下，我选择回滚代码。 # 具体操作： 第一种方法： 注意：这种方法会把之后的代码完全覆盖掉，不建议使用，除非这个分支只有你自己操作，或者你回滚的版本之后没有别的人提交 首先要找到你要回滚的版本号。 ​ 在 idea 中操作：右键项目 -&gt; Git -&gt; Show History -&gt; 右键提交的版本 -&gt; Copy Revision Number。 ​ 在 GIT 中操作：找到提交的历史，SHA 值，即为版本号。 Git Bush 命令行 /idea TerMinal 命令行 ​ git reset --hard 版本号 第二种方法： 找到版本号，同上。 右键项目 -&gt; Git -&gt; Repository -&gt; Reset HEAD 在 To Commit 中输入版本号 # 最后： ​ 记得一定要提交代码，即使看起来没有要 push 的东西，否则 git pull 之后等于没回滚。 # 2. 构建相关 # 场景： ​ 回滚代码之后，本地可以成功构建，但服务器端无法正常构建。 # 具体描述： ​ 服务器端构建一直失败，好像是拉取到了错误版本的代码。 # 具体操作： ​ 暴脾气的我本来打算把项目删了重新拉一个下来，后来忍住了，在服务器端回滚了一下代码，然后手动构建了一下，居然成功了，完结。 # 最后： ​ 虽然没什么有用的东西，不过思路还是有的。 ​ 首先你要确认本地构建的代码是否和服务器完全相同、服务器构建的时候是否 pull 了最新的代码...","categories":[],"tags":[{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"}]}],"categories":[{"name":"use","slug":"use","permalink":"https://fairyeye.github.io/categories/use/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://fairyeye.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"杂谈","slug":"杂谈","permalink":"https://fairyeye.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"java","slug":"java","permalink":"https://fairyeye.github.io/categories/java/"},{"name":"中间件","slug":"中间件","permalink":"https://fairyeye.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"实用","slug":"实用","permalink":"https://fairyeye.github.io/categories/%E5%AE%9E%E7%94%A8/"},{"name":"杂项","slug":"杂项","permalink":"https://fairyeye.github.io/categories/%E6%9D%82%E9%A1%B9/"},{"name":"工具使用","slug":"工具使用","permalink":"https://fairyeye.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"git","slug":"git","permalink":"https://fairyeye.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://fairyeye.github.io/tags/hexo/"},{"name":"demo","slug":"demo","permalink":"https://fairyeye.github.io/tags/demo/"},{"name":"utils","slug":"utils","permalink":"https://fairyeye.github.io/tags/utils/"},{"name":"mysql","slug":"mysql","permalink":"https://fairyeye.github.io/tags/mysql/"},{"name":"基础","slug":"基础","permalink":"https://fairyeye.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"学习","slug":"学习","permalink":"https://fairyeye.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"https://fairyeye.github.io/tags/Java/"},{"name":"dairy","slug":"dairy","permalink":"https://fairyeye.github.io/tags/dairy/"},{"name":"系统集成","slug":"系统集成","permalink":"https://fairyeye.github.io/tags/%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90/"},{"name":"软件","slug":"软件","permalink":"https://fairyeye.github.io/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://fairyeye.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"others","slug":"others","permalink":"https://fairyeye.github.io/tags/others/"},{"name":"redis","slug":"redis","permalink":"https://fairyeye.github.io/tags/redis/"},{"name":"basic","slug":"basic","permalink":"https://fairyeye.github.io/tags/basic/"},{"name":"hexo,theme,shoka","slug":"hexo-theme-shoka","permalink":"https://fairyeye.github.io/tags/hexo-theme-shoka/"}]}