---
title: Hello Algo
description: 算法
tags:
  - 学习
date: 2023-12-25 16:04:09
---


二分搜索、插入排序、贪心



迭代、递归


```
# n >= 1 时
T(n) = 3+2n <= 3n+2n = 5n
T(n) <= c * f(n)
T(n) = O(f(n))
```




### KMP


#### 求`next[]`

```
next[]：找出一个以0下标(必须0下标)开始，以j-1下标结束的两个相同子串
=>next[j-1] => k-1
```

![](https://s3.bmp.ovh/imgs/2023/12/28/114225dc0dc58919.png)

```
哈哈               k        x     j            
下标k       0   1  2  3  4  5  6  7  8  9  10 11 12 13
数组p       a   b  a  b  c  a  b  c  d  a  b  c  d  e
next数组    -1  0  0  1  2  0  1  2  0  0  1  2  0  0

j++
下标0 = a
当 j = 3:
	下标j-1=2 -> a     可以找到 a、aba、a  但是aba不满足条件     =>  1
当 j = 4:
	下标j-1=3 -> b     可以找到 ab、abab   但是abab不满足条件   =>  2
当 j = 5:
	下标j-1=4 -> c     可以找到 ababc   不满足条件  =>  0


哈哈               k        x     j            
下标k       0   1  2  3  4  5  6  7  8  9  10 11 12 13
数组p       a   b  a  b  c  a  b  a  d  a  b  c  d  e
next数组    -1  0  0  1  2  0  1  2  3  0  1  2  0  0

已知条件：
以0下标(必须0下标)开始，以j-1下标结束的两个相同子串
p[0]..p[k-1] = p[x]..p[j-1]
得出：
=> k-1-0 = j-1-x 
=> k = j-x
=> x = j-k
==> p[0]..p[k-1] = p[j-k]..p[j-1]
假设：p[k] = p[j]
=> p[0]..p[k] = p[j-k]..p[j]
所以 next[j] = k  

k-1 = next[j-1]
p[0]..p[k-1] = p[x]..p[j-1]
假设：p[k] = p[j]
p[0]..p[k-1]p[k] = p[x]..p[j-1]p[j]
p[0]..p[k] = p[j-k]..p[j]
k = next[j]




```



### 数组

优点：
- 空间效率高
- 支持随机访问
- 缓存局部性？
缺点：
- 插入与删除效率低
- 长度不可变  
- 空间浪费
典型应用：
- 随机访问
- 排序、搜索
- 查找表
- 机器学习
- 数据结构实现

### 链表



### 数组 vs 链表

- 存储方式
- 容量扩展
- 内存效率
- 访问元素
- 添加元素
- 删除元素
